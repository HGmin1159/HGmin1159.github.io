---
title: \[Quantum Data Science\] Part 2. Introduction to Quantum Theory
categories: [Quantum]
tags: [Quantum Computer]
excerpt: Basic Terminology used at the Quantum Theory
---



 Compare to the classical computing, quantum computing usually includes an additional step when solving data science problem. Before learning quantum circuit, we need to load the data into circuit. The procedure is called as *state preparation*. 

 We need this step because quantum version of RAM are not invented yet. This step is also called as quantum encoding and there are various quantum encoding methods. Different circuit takes different strategy to encode the quantum. 

 In this posting, let's see four different strategies to implement the data: Basis encoding, Amplitude encoding, Qsample Encoding, Hamiltonian Encoding. 

$\def\ket#1{\mid #1 \rangle}\def\bra#1{\langle #1 \mid}$

## 1. Basis Encoding

Let's assume that we have a binary dataset whose elements can be represented as  $x_i = \{b_{1i},b_{2i},...,b_{pi}\},i=1,2,...N$ . The first subscript indicates index of feature and the second one indicates index of sample. Therefore, the design matrix is $N \times P$.

 For them, the basis encoding prepares the density matrix as $\ket{D}\bra{D} = \frac{1}{N} \sum_{i=1}^N \ket{x_i}\bra{x_i}$. It can be interpreted as superposition of each data point which is weighted by the total number of same data. For example, let's assume following data matrix.

| Index | $b_1$ | $b_2$ | $b_3$ | $b_4$ |
| ----- | ----- | ----- | ----- | ----- |
| 1     | 1     | 0     | 0     | 1     |
| 2     | 0     | 1     | 0     | 0     |
| 3     | 1     | 0     | 0     | 1     |
| 4     | 1     | 1     | 0     | 0     |
| 5     | 1     | 1     | 1     | 1     |

The basis encoded data matrix is follow.
$$
\ket{D}\bra{D} = \frac{1}{5}\ket{1001}\bra{1001} + \frac{1}{5}\ket{0100}\bra{0100}+\frac{1}{5}\ket{1001}\bra{1001}+\frac{1}{5}\ket{1100}\bra{1100}+\frac{1}{5}\ket{1111}\bra{1111} \\ =\frac{2}{5}\ket{1001}\bra{1001} + \frac{1}{5}\ket{0100}\bra{0100}+\frac{1}{5}\ket{1100}\bra{1100}+\frac{1}{5}\ket{1111}\bra{1111}
$$
The state vector of it is below
$$
\ket{D} = \frac{\sqrt{2}}{\sqrt{5}} \ket{1001} +\frac{1}{\sqrt{5}} \ket{0100}+\frac{1}{\sqrt{5}} \ket{1100}+\frac{1}{\sqrt{5}} \ket{1111}
$$
As you can see, the number of possible states are $2^4 =16$ but only four of them are non-zero. That is, the amplitude vector is $\alpha = (0,0,0,0,\frac{1}{\sqrt{5}},0,0,0,0,\frac{\sqrt{2}}{\sqrt{5}},0,0,\frac{1}{\sqrt{5}},0,0,\frac{1}{\sqrt{5}})$.  Therefore, in the basis encoding, the amplitude vector become sparse or at least imbalanced.



 We can see the example of basis encoding at the quantum phase estimation. The result of the circuit is the phase represented as binary number such as $\ket{0100101011}$



## 2. Amplitude Encoding

 The Amplitude Encoding is much more famous encoding method than any other method. It is because it directly encodes the form of the vector. 
$$
\ket{\psi_D} = \underset{j=1}{\overset{P}{\sum}} \underset{i=1}{\overset{N}{\sum}}x_{ij}\ket{i}\ket{j}
\\\
= \underset{j=1}{\overset{P}{\sum}} \ket{\psi_{xi}}\ket{j}
$$
This could be interpreted as store $x_{ip}$ value in the amplitude of index state $\ket{i}\ket{j}$. Or, it could be interpreted as $vec(X_d)$.

The amplitude vector of it is $\alpha = (x_{11},x_{12},...,x_{1p},x_{21},...,x_{np})^t$. For them, we have to normalize the vector to make it satisfying $\mid \alpha \mid^2 =1$.

 If the target data is just vector, then it has same form with the vector itself.(Of course, the data vector have to be normalized first)

$x = \left[\begin{array}{c}x_1 \\\ x_2 \\\ \vdots \\\ x_N \end{array}\right] = \sum_{j=1}^{N} x_j \ket{j}$

For the $2^{n-1}< N \leq 2^n$, we can use n qubit and for remaining space $2^n-N$ could be encoded as zero which is called as ancilla state.

 Notice that for general state $\ket{\psi} = \sum \alpha_i \ket{i}$, if the data is encoded at $\alpha_i$, then it is called as an amplitude encoding and if the data is encoded at $\ket{i}$, then it is called as a basis encoding.

 The amplitude encoding has an advantage that only needs $n=\log NP$ qubits to encode the data matrix whereas the basis encoding needs $ n = P$ qubits.

 

 The amplitude encoding could directly implement some matrices or vectors. Therefore, it is generally used at linear algorithms including HHL algorithm or qPCA.



## 3. Qsample Encoding

Qsample encoding is method to connect a concept of probability distribution of discrete random variable to former state form. 

Assume there is a pmf of random variable X as $Pr(X=i) = p_i$. Any discrete random variable could be represented like it just by indexing the events. For them, we can define qubit state as $\ket{\psi} = \underset{i=1}{\overset{N}{\sum}} p_i \ket{i}$. 

In the view of Qsample encoding, the basis encoding could be understood as empirical distribution function because the amplitudes of basis encoding are the weights of the data which could be interpreted as empirical probabilities.

 

 By using the Qsample encoding, we could express a joint probability of several random variable too.

For states of two random variables $\ket{x} = \underset{i=1}{\overset{2^n}{\sum}} \sqrt{Pr(x=i)} \ket{i}$ and $\ket{y} = \underset{j=1}{\overset{2^n}{\sum}} \sqrt{Pr(y=j)} \ket{j}$, the joint state of two random variable is $\ket{x,y} = \underset{i,j}{\overset{2^n}{\sum}} \sqrt{Pr(x=i)Pr(y=j)}\ket{i}\ket{j}$ if two random variables are independent and  $\ket{x,y} = \underset{i,j}{\overset{2^n}{\sum}} \sqrt{Pr(x=i,y=j)}\ket{i}\ket{j}$ if two random variables are dependent each other.

 

We can observe that the definition could directly express the random variable. Even though random variable is a kind of function, but we usually interpret it as a instance which emit some real value with respect to some probability. In this manner, the random variable could be interpreted as a qubit because both of them could return a specific real value with measurement (observation) and before we observe them, they are some potential instances which could be any real value.

  By developing the concept, we might be able to build special statistical model.



## 4. Hamiltonian Encoding

 The Hamiltonian Encoding is little bit different encoding method with previous methods. In the previous methods, we encode data in the states of qubit. Meanwhile the hamiltonian encoding method encodes the data into the operator.

 To make some matrix A to Hamiltonian, we have to make it Hermitian first. Because the definition of Hermitian is $H = H^{\ast}$, we can make it by $H = A^\ast A \quad(H^\ast = A^\ast A)$ 

 Then to make them as unitary matrix, we can use matrix exponential as $e^{-iAt}$. 

There is a theorem that any hermitian matrix could be decomposed with Pauli gates. 
$$
\mbox{ For any unitary matrix } A, \mbox{ there is a real vector }(\alpha,\beta,\gamma,\delta) \mbox{ such that } A = \alpha+\beta X + \delta Y + \gamma Z
$$
By using it, we can develop unitary evolution as follow.
$$
e^{i A t} = e^{i(\alpha + \beta X + \delta Y + \gamma Z)t} \\\ = e^{i\alpha t I} e^{i\beta t X} e^{i \delta t Y} e^{i\gamma t Z} \\\ = R_x(\beta t) R_y(\delta t) R_z( \gamma t)
$$
That is, we can express any unitary evolution by three rotation operators. 



However, in reality, it cannot be done. This is because the commutative rule do not hold for matrices. That is, $AB\neq BA$ so $e^{A+B} \neq e^{A}e^{B}$. 

However, we can overcome this one by using Trotter Suzuki formula.
$$
\mbox{ For large enough r, the following equation holds } e^{-i(H_1+H_2)t} \approx (e^{-i H_A t/r}e^{-i H_B t/r})^r
$$
That is, we can implement some hamiltonian unitary matrices by finding the rotate magnitudes and rotating the state with them gradually.



 The hamiltonian encoding method is densely connected with Physics. Therefore, various physical algorithms including VQE and QAOA are developed with hamiltonian encoding method.

***

Schuld, M. & Petrucionne, F. (2019). Supervised Learning with Quantum Computers,Cham, Switzerland:Springer

